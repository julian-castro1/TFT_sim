const e={TFT_BLACK:0,TFT_WHITE:65535,TFT_RED:63488,TFT_GREEN:2016,TFT_BLUE:31,TFT_CYAN:2047,TFT_MAGENTA:63519,TFT_YELLOW:65504,TFT_ORANGE:64800,TFT_DARKGREY:31727,TFT_LIGHTGREY:50712,TFT_NAVY:15,TFT_DARKGREEN:992,TFT_DARKCYAN:1007,TFT_MAROON:30720,TFT_PURPLE:30735,TFT_OLIVE:31712,TFT_PINK:63519,TFT_GREENYELLOW:45029};function t(e){const t=255*(e>>11&31)/31,n=255*(e>>5&63)/63,s=255*(31&e)/31;return`#${(Math.round(t)<<16|Math.round(n)<<8|Math.round(s)).toString(16).padStart(6,"0")}`}function n(n){if(n.startsWith("TFT_")){const s=e[n];return void 0!==s?t(s):"#000000"}const s=n.match(/rgbToHex\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);if(s){return`#${(parseInt(s[1])<<16|parseInt(s[2])<<8|parseInt(s[3])).toString(16).padStart(6,"0")}`}if(n.startsWith("0x")){return t(parseInt(n,16))}if(n.match(/^\d+$/)){return t(parseInt(n))}return"#000000"}function s(e){return t=this,n=null,s=function*(){const t={screens:[],states:[],variables:[],functions:[],includes:[],errors:[]};try{const s=e.split("\n");t.includes=function(e){const t=[];return e.forEach(e=>{const n=e.match(/#include\s*[<"](.*?)[>"]/);n&&t.push(n[1])}),t}(s),t.states=function(e){const t=[];return e.forEach((e,n)=>{const s=e.match(/enum\s+(\w+)\s*\{([^}]+)\}/);s&&s[2].split(",").map(e=>e.trim()).forEach(e=>{e&&t.push({name:e,value:e,type:"enum",screens:[]})});const r=e.match(/(\w+)\s+(\w+)\s*=\s*(\w+)/);r&&e.includes("State")&&t.push({name:r[2],value:r[3],type:"variable",screens:[]})}),t}(s),t.variables=function(e){const t=[];return e.forEach((e,n)=>{const s=e.match(/^\s*(int|uint16_t|bool|float|double|char\*?)\s+(\w+)/);s&&t.push({name:s[2],type:s[1],value:null,scope:"global",line:n+1})}),t}(s),t.functions=function(e){const t=[];return e.forEach((e,n)=>{const s=e.match(/^\s*(void|int|bool|float|double|char\*?)\s+(\w+)\s*\(([^)]*)\)/);s&&t.push({name:s[2],returnType:s[1],parameters:s[3]?s[3].split(",").map(e=>e.trim()):[],body:"",line:n+1})}),t}(s),t.screens=function(e,t){const n=[];if(t.filter(e=>e.name.startsWith("draw")).forEach(t=>{const s={id:t.name,name:t.name,elements:[],touchZones:[],backgroundColor:"#000000",transitions:[]},{elements:o,touchZones:i}=r(e,t.name);s.elements=o,s.touchZones=i,n.push(s)}),0===n.length){const{elements:t,touchZones:s}=r(e,"main");n.push({id:"main",name:"Main Screen",elements:t,touchZones:s,backgroundColor:"#000000",transitions:[]})}return n}(s,t.functions),0===(n=t).screens.length&&n.errors.push({message:"No screens found. Make sure your code includes drawing functions.",line:0,column:0,severity:"warning"}),n.includes.includes("TFT_eSPI.h")||n.errors.push({message:"TFT_eSPI.h not found in includes. Make sure to include the library.",line:0,column:0,severity:"warning"})}catch(s){t.errors.push({message:`Parse error: ${s instanceof Error?s.message:"Unknown error"}`,line:0,column:0,severity:"error"})}var n;return t},new Promise((e,r)=>{var o=e=>{try{c(s.next(e))}catch(t){r(t)}},i=e=>{try{c(s.throw(e))}catch(t){r(t)}},c=t=>t.done?e(t.value):Promise.resolve(t.value).then(o,i);c((s=s.apply(t,n)).next())});var t,n,s}function r(e,t){const s=[],r=[];let o=!1,i=0,c=0;return e.forEach((a,u)=>{const l=a.trim();if(l.includes(`${t}(`)&&l.includes("{"))return o=!0,void(i=1);if(o)if(i+=(a.match(/\{/g)||[]).length,i-=(a.match(/\}/g)||[]).length,0!==i){if(l.includes("tft.")){const e=function(e,t){const s=e.trim();if(s.includes("fillScreen")){const e=s.match(/fillScreen\s*\(\s*([^)]+)\s*\)/);if(e)return{id:`bg_${t}`,type:"rectangle",x:0,y:0,width:380,height:420,color:n(e[1]),backgroundColor:n(e[1]),visible:!0,zIndex:0}}if(s.includes("fillRect")){const e=s.match(/fillRect\s*\(\s*([^,]+),\s*([^,]+),\s*([^,]+),\s*([^,]+),\s*([^)]+)\s*\)/);if(e)return{id:`rect_${t}`,type:"rectangle",x:parseInt(e[1]),y:parseInt(e[2]),width:parseInt(e[3]),height:parseInt(e[4]),color:n(e[5]),backgroundColor:n(e[5]),visible:!0,zIndex:1}}if(s.includes("fillSmoothRoundRect")){const e=s.match(/fillSmoothRoundRect\s*\(\s*([^,]+),\s*([^,]+),\s*([^,]+),\s*([^,]+),\s*([^,]+),\s*([^,]+)(?:,\s*([^)]+))?\s*\)/);if(e)return{id:`roundrect_${t}`,type:"roundedRectangle",x:parseInt(e[1]),y:parseInt(e[2]),width:parseInt(e[3]),height:parseInt(e[4]),radius:parseInt(e[5]),color:n(e[6]),backgroundColor:n(e[6]),visible:!0,zIndex:1}}if(s.includes("drawString")){const e=s.match(/drawString\s*\(\s*"([^"]+)"\s*,\s*([^,]+),\s*([^)]+)\s*\)/);if(e)return{id:`text_${t}`,type:"text",x:parseInt(e[2]),y:parseInt(e[3]),text:e[1],color:"#ffffff",visible:!0,zIndex:2,fontSize:16,textAlign:"center"}}return null}(l,c++);e&&s.push(e)}if(l.includes("getTouch")||l.includes(">=")&&l.includes("<=")){const t=function(e,t,n){const s=e.match(/x\s*>=\s*(\d+)\s*&&\s*x\s*<=\s*(\d+)\s*&&\s*y\s*>=\s*(\d+)\s*&&\s*y\s*<=\s*(\d+)/);if(s){const e=parseInt(s[1]),r=parseInt(s[2]),o=parseInt(s[3]),i=parseInt(s[4]);let c="touch";for(let s=n+1;s<Math.min(n+5,t.length);s++){const e=t[s].trim();if(e.includes("=")){const t=e.match(/(\w+)\s*=\s*(\w+)/);if(t){c=t[2];break}}}return{id:`touch_${n}`,x:e,y:o,width:r-e,height:i-o,action:c,visible:!0,debugColor:"#ff0000"}}return null}(l,e,u);t&&r.push(t)}}else o=!1}),{elements:s,touchZones:r}}export{s as p};
